---
layout: post
title: "JSON Merge Patch for .NET"
comments: true
description: "A pattern for implementing the JSON Merge Patch Spec in .NET"
keywords: ".net, web api, asp.net, json merge patch"
---

At my day job, I have been working on a new microservice that sits behind a REST API.  I got to the point where I needed to
support updating some resources, and was looking for the "right" RESTful way to accept update requests.  After some research,
I found two options that seemed to fit my needs well, [JSON Patch](https://tools.ietf.org/html/rfc6902)
and [JSON Merge Patch](https://tools.ietf.org/html/rfc7386).

### JSON Patch
I think of JSON Patch like assembly code for updating a resource.  The JSON Patch document contains an array of
operations to perform on the specified resource.  Each operation describes some change that should be made.  Here is an example
from the RFC:

```
PATCH /my/data HTTP/1.1
Host: example.org
Content-Length: 326
Content-Type: application/json-patch+json
If-Match: "abc123"

[
  { "op": "test", "path": "/a/b/c", "value": "foo" },
  { "op": "remove", "path": "/a/b/c" },
  { "op": "add", "path": "/a/b/c", "value": [ "foo", "bar" ] },
  { "op": "replace", "path": "/a/b/c", "value": 42 },
  { "op": "move", "from": "/a/b/c", "path": "/a/b/d" },
  { "op": "copy", "from": "/a/b/d", "path": "/a/b/e" }
]
 ```

This example shows the different types of operations defined in the RFC.  The idea is not very complex.  There are only
a handful of operations, and if I squint my eyes, I can see what is going on.  But, something about the format just
feels unnatural.  Some of the cool things about REST are how human friendly it is, how discoverable a well designed API
can be.  If I want to get a resource, I send a GET request, and the URL generally maps nicely to the thing I am looking
for.  If I want the `thing` with `ID=1` I ask for `/thing/1`.  When I look at a JSON Patch request, I see assembly code,
and I just don't like it.

FWIW, .NET does has some support for [JSON Patch](https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.jsonpatch.jsonpatchdocument-1?view=aspnetcore-2.2).  And if you combine that with some
[client side libraries](https://www.npmjs.com/package/fast-json-patch), generating the patch document would be feasible.
But I just wasn't sold on the approach.

### JSON Merge Patch
JSON Merge Patch attempts to solve a similar problem as JSON Patch but takes a different approach.  While I see JSON Patch
documents as assembly code, a JSON Merge Patch looks more like a Diff between two documents.  Again, lets look an example
from the RFC:

```
PATCH /target HTTP/1.1
Host: example.org
Content-Type: application/merge-patch+json

{
  "a":"z",
  "c": {
    "f": null
  }
}
```

In a JSON Merge Patch request, the shape of the JSON object is the same as that of the resource you want to update,
however, you only specify the fields you want to change.  In this case, we should update the `a` field, assigning it
the value `z`.  Also, `c.f` should be set to `null`.  Imagine the target resource for the above request had some
field `b = 123`.  Since it was ommitted from the patch request, that field should not be changed.

I find a certain elegance in this approach.  No special syntax, just send the fields you want to update. Admittedly,
it is not as flexible as the JSON Patch format.  For instance, there is not a succinct way to express that you want to remove a
single item from an array.  To modify an array, the merge patch request should include the entire modified array.  Contrast
that with JSON Patch, where you could send an operation like `{"op": "remove", "path": "/things/1"}`.

Even with the constraints, I still prefer the JSON Merge Patch approach.  It just feels right.  Unfortunately, .NET
does not currently have any support for it.  At the time of this writing, there is an
[open issue](https://github.com/aspnet/AspNetCore/issues/2436) on the ASP.NET Core GitHub repo, but there hasn't been
any movement.  A couple of community members have offerred solutions, but they didn't quite work for my needs.  So,
lets see if we can come up with a workable solution.

### A Naive Approach
Let's start with the simplest thing that could possibly work.  Imagine in our app, we have a `Person` class.  A
person has a `Name` and an `Address`.

```csharp
public class Person
{
    public Guid Identifier { get; set; }
    public string? Name { get; set; }
    public Address? Address { get; set; }
}

public class Address
{
    public string? Street { get; set; }
    public string? City { get; set; }
    public string? State { get; set; }
    public string? ZipCode { get; set; }
}
```

We need to expose a way to update a person.  So we might create an endpoint like this:

```csharp
[ApiController]
public class ApiController
{
    [HttpPatch]
    [Route("naivepatch/person/{personId}")]
    public IActionResult NaivePatch(Guid personId, [FromBody]Person data)
    {
        // TODO update person
    }
}
```

Given a request like:

```
PATCH /naivepatch/person/1c8ff3f2-16d5-4a5a-94d1-52f25f2a80e6 HTTP/1.1
Content-Type: application/json
Host: localhost:5000
Content-Length: 33

{
    "name": "test person"
}
```

According to the JSON Merge Patch spec, we should only update the fields that are supplied in the request (in this case, update `Name`
setting the value to "test person").  We might try and write some code like:

```csharp
var person = /* load from data store using personId */;
            
if (data.Name != null)
{
    person.Name = data.Name;
}

if (data.Address != null)
{
    person.Address = data.Address;
}

/* save updated person */
```

This should handle our request just fine.  We are done then, right?  Not quite.  How would we handle a request like:

```
PATCH http://localhost:5000/naivepatch/person/1c8ff3f2-16d5-4a5a-94d1-52f25f2a80e6 HTTP/1.1
Content-Type: application/json
Host: localhost:5000
Content-Length: 26

{
   "address": null
}
```

The intent of this request is to clear this person's address, setting it to `null`.  However, after model binding has completed,
there is no way for us to tell in our controller action whether Person.Address is `null` because `address` was not included in
the request, or `null` because `address` was set to `null` in the request.

We are going to need to do a bit more work.

### A Better Design
Simple csharp classes do not give us a way to distinguish between a `null` value and an `undefined` value, so we will need
to wrap the model being passed into our action in a way that allows for this distinction.  Imagine if instead of accepting a
`Person` in our controller action, we did something like:

```csharp
[HttpPatch]
[Route("betterpatch/person/{personId}")]
public IActionResult BetterPatch(Guid personId, [FromBody]JsonMergePatch<Person> data)
{
    var person = /* load from data store using personId */;

    if (data.IsDefined(x => x.Name, out var name))
    {
        person.Name = name;
    }

    if (data.IsDefined(x => x.Address, out var address))
    {
        person.Address = address;
    }

    /* save updated person */

    return new OkResult();
}
```

This hypothetical `JsonMergePatch<T>` class would allow us to first inspect whether a value was supplied in the request,
and if so, extract the value and do something with it.  Sadly this class does not actually exist... yet.  Let's build it.

